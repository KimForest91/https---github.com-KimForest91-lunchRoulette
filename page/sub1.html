<!DOCTYPE html>
<html lang="ko">
  <head>
<!--     <base href="/"> -->
    <meta charset="utf-8" />
    <title>sub1 | forestKim</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
    <meta name="apple-mobile-web-app-title" content="forestKim" />                                     
    <meta name="description" content="forestKim" />
    <link rel="stylesheet" href="./../assets/lib/fa/css/all.min.css" />
    <link rel="stylesheet" href="./../css/web-font.css" />
    <link rel="stylesheet" href="../css/reset.css" />
    <link rel="stylesheet" href="../css/style-pc.css" media="all and (min-width: 1024.0px)" />
    <link rel="stylesheet" href="../css/style-m.css" media="all and (max-width: 1023.9px)" />
    <script src="../js/jquery-3.6.1.min.js"></script>
    <script src="../js/common.js"></script>
  </head>
  <body class="sub1">
  
    <div id="wrapper">
      <a href="#main" id="skip-nav">본문 바로가기</a>
      <header id="header">

      </header>

      <main id="main">

      </main>

      <footer id="footer">

      </footer>
    </div>
<script>
'use strict';
  

/* let arr = [10, 3, 40];

function addNumber(a, b, c) {
  console.log(a + b + c);
}

addNumber(arr[0], arr[1], arr[2]);
addNumber.apply(undefined, arr);  // 옛날방식
addNumber(...arr);  // 요즘방식

 */
/* 
function add(a, b = a * 3) {
  console.log('answer is ' + a + b);
}

add(1);

function temporary() {
  return 10;
}

function newFunction(a, b = temporary()) {
  console.log('newfunction is ' + a + b);
};

newFunction(3, 5); */

// arguments 는 옛날 문법임


/* 
var a = [1,2,3];
var b = '김밥';
var c = [...b, ...a];
console.log(c);
 */

/* var a = [1,2,3];
var b = ['you', 'are'];
var c = function(a,b){
  console.log( [[...a], ...[...b]][1] )
}
c(a,b); */

/* 
function 함수(a = 5, b = a * 2 ){
  console.log(a + b);
  return 10;
}
함수(3);
*/
/* 
function 함수(a = 5, b = a * 2 ){
  console.log(a + b);
}
함수(undefined, undefined);
 */

/* var numbers = [2,3,4,5,6,1,3,2,5,5,4,6,7];
console.log(Math.max(...numbers)); */
/* 
function 정렬(글자){
  console.log( ...[...글자].sort() )
}

정렬('bear'); 
 */
/* 
function 글자세기(글){
  var 결과 = {};
  [...글].forEach(function(a){
    if( 결과[a] > 0 ){ 결과[a]++ } else { 결과[a] = 1 } 
  }); 
  console.log(결과)
}


글자세기('aabbeccee');
*/


/*  Reference data type */
/* 
let name1 = 'kim';
let name2 = name1;

name1 = 'park'

console.log(name2);
console.log(name1);
 */
/* 
let name1 = { name : 'kim' };
let name2 = name1;

name1.name = 'park';

console.log(name1);
console.log(name2);
 */
/* 
let student1 = { name: 'Kim', age: '15' };

// constructure 문법에서는 대문자로
function Student(a) {
  this.name = a;
  this.age = 15;
  this.sayHi = function() {
    console.log('안녕하세요' + this.name + '입니다.');
  }
  this.sayHi = '안녕하세요 ' + this.name + ' 입니다.';
    
}

let student2 = new Student('park');
console.log(student2.sayHi);


function Product(goods, price){
  this.name = goods;
  this.price = price;
  this.vat = this.price * 0.1;
}

var product1 = new Product('shirts', 50000);
var product2 = new Product('pants', 60000);

console.log(product1.vat);
 */


/* Class 문법 */
class parent {
  constructor(a) {
    this.name = a;
    this.sayHi = function() {console.log('Hi! :)');}
  }

  sayHello() {  //얘는 물려받는 함수가 아님 부모의 프로토타입에 추가되는 함수
    console.log('hello!');
  }
}

let child = new parent('내이름');

// console.log(child);
// console.log(child.__proto__);
// Object.getPrototypeOf(child);


parent.prototype.sayGoodbye = function() {
  console.log('Good Bye!!!');
}
// console.log(child.__proto__);


class grandpa {
  constructor(name) {
    this.lastName = 'kim';
    this.firstName = name;
  }
  sayHi() {
    console.log('HiHi~~~');
  }
}

let grandpa1 = new grandpa('만덕');

class father extends grandpa {
  constructor(name) {
    super(name);
    this.age = 58;  //extends를 사용한 함수에는 this를 쓸 수 없다. 그래서 앞에 super()를 붙여줌.
  }
  sayHi() {
    console.log('안녕 나는 아빠야.');
    super.sayHi();
  }
}

let father1 = new father('희희');

// console.log(father1.sayHi);


let person = {
  name: 'park',
  age: 30,
  get nextAge() {
    return this.age + 1;  //getter는 파라미터가 없고, return이 있어야 함
  },
  set setAge(age2) {
    this.age = parseInt(age2);
  }
}

// person.nextAge();
// console.log(person.age);

// person.setAge(300);
// console.log(person.age);



class human {                  //class 에서도 get set 사용 가능
  constructor() {
    this.name = 'Park';
    this.age = 40;
  }
  get nextAge() {
    return this.age + 1;
  }
  set setAge(e) {
    this.age = e;
  }

}

let human1 = new human();















 











</script>

  </body>
</html>



